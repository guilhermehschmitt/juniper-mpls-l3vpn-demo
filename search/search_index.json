{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"docs/overview/","text":"\ud83c\udf89 Welcome This project is for network developers looking to build, deploy, and validate an MPLS network on Juniper vMX routers. For those looking to get started with either network automation or MPLS L3VPN circuits, this project can help you get familiar with the concepts and technologies necessary for success. \u2753 How to use this guide The navigation menu on the left hand of this site will be the best method of navigating between the documents. Automation This is the meat and potatoes of our documentation, even for those just looking for an MPLS example. We will cover how configurations are built, where they are stored, and how do they get pushed to our remote devices. Network validation will also be leveraged to ensure us that the MPLS L3VPN circuit is working. The all-important code deep dive will be taking place here, and we will discuss the various tools that are provided in the project files to make our lives easier. Network This can be considered optional if you're only here for the Python, but it's really cool too. We will cover topics like IP addressing, MPLS configurations, and control-plane details. Lab Environment This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Overview"},{"location":"docs/overview/#welcome","text":"This project is for network developers looking to build, deploy, and validate an MPLS network on Juniper vMX routers. For those looking to get started with either network automation or MPLS L3VPN circuits, this project can help you get familiar with the concepts and technologies necessary for success.","title":"\ud83c\udf89 Welcome"},{"location":"docs/overview/#how-to-use-this-guide","text":"The navigation menu on the left hand of this site will be the best method of navigating between the documents.","title":"\u2753 How to use this guide"},{"location":"docs/overview/#automation","text":"This is the meat and potatoes of our documentation, even for those just looking for an MPLS example. We will cover how configurations are built, where they are stored, and how do they get pushed to our remote devices. Network validation will also be leveraged to ensure us that the MPLS L3VPN circuit is working. The all-important code deep dive will be taking place here, and we will discuss the various tools that are provided in the project files to make our lives easier.","title":"Automation"},{"location":"docs/overview/#network","text":"This can be considered optional if you're only here for the Python, but it's really cool too. We will cover topics like IP addressing, MPLS configurations, and control-plane details.","title":"Network"},{"location":"docs/overview/#lab-environment","text":"This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Lab Environment"},{"location":"docs/automation/configure/","text":"\ud83d\udccc Overview Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations. \ud83d\udc0d Files All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Python Scripts You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy. Inventory file The inventory.yaml file stores information about our devices, basic information like hostname and IP address. configurations/ directory If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations. templates/ directory Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory. vars/ directory Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations. \ud83d\udee0\ufe0f Tools In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project. Poetry A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. Invoke You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"configure"},{"location":"docs/automation/configure/#overview","text":"Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/configure/#files","text":"All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py","title":"\ud83d\udc0d Files"},{"location":"docs/automation/configure/#python-scripts","text":"You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy.","title":"Python Scripts"},{"location":"docs/automation/configure/#inventory-file","text":"The inventory.yaml file stores information about our devices, basic information like hostname and IP address.","title":"Inventory file"},{"location":"docs/automation/configure/#configurations-directory","text":"If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations.","title":"configurations/ directory"},{"location":"docs/automation/configure/#templates-directory","text":"Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory.","title":"templates/ directory"},{"location":"docs/automation/configure/#vars-directory","text":"Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations.","title":"vars/ directory"},{"location":"docs/automation/configure/#tools","text":"In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project.","title":"\ud83d\udee0\ufe0f Tools"},{"location":"docs/automation/configure/#poetry","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"Poetry"},{"location":"docs/automation/configure/#invoke","text":"You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"Invoke"},{"location":"docs/automation/configure/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Dockerfile"},{"location":"docs/automation/configure/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/configure.py/","text":"\ud83d\udccc Overview This script will be ran when you'd like to generate and push a device's configuration using PyEZ. \ud83d\udc0d Files Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the configure.py script. \ud83d\udcdd Code Deep Dive Imports We will be importing inventory data into our script from a local file named inventory.yaml , so we need to import yaml to handle this functionality. import yaml from jnpr.junos import Device from jnpr.junos.utils.config import Config Two primary functions of PyEZ will be imported, the first of which is the Device object. Device will allow us to model our device's parameters, things like IP address, username, and the sort. But Device will also enable us to build and maintain a NETCONF session to our remote device, so this object Class really does most of the heavy lifting here. From the utilities module, we will be importing the Config class, which will (obviously) handle the configuration aspects of our script. Configurations We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter. Inventory We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices . main() For our script's main function, we will loop over our list of routers that we imported from inventory.yaml to open a NETCONF session. def main ( devices ): for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) dev . open () After printing a status message to the console, we will be creating an empty dictionary called data and then stuffing our YAML vars into it as data['configuration'] . The only reason this is here is to help handle the fact that PyEZ and Jinja2 library load YAML vars differently than each other. print ( f \"connected to { each [ 'name' ] } \" ) data = dict () data [ \"configuration\" ] = yaml . safe_load ( open ( f \"vars/ { each [ 'name' ] } .yaml\" )) We pass on the object that represents our device into the Config class, which will create a new object called configuration to represent our device's configuration. configuration = Config ( dev ) configuration . load ( template_path = \"templates/junos.j2\" , template_vars = data , format = \"set\" ) Next we see that we run the load method of our recently created configuration object, and we pass it three options: Point to our Jinja2 template file at templates/junos.j2 Point to our device's variables (the data object created above) Declare that our configuration is in the set format, alternatives would be text , xml , or json This will push the device's configuration to the candidate config database, but will not commit it just yet. We perform three functions upon the candidate configuration database: Report any configuration diff to the console. Perform a configuration check to make sure our generated configuration is valid. Commit the configuration. configuration . pdiff () if configuration . commit_check (): configuration . commit () else : configuration . rollback () dev . close () Should the configuration fail the configuration check, roll back to the previous state. Close our NETCONF session. Initialize There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. if __name__ == \"__main__\" : devices = inventory () main ( devices ) We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices. \ud83d\ude80 Workflow Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python configure.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke configure \ud83d\udc0d Script \"\"\"Generate production configurations and push to our network devices.\"\"\" import yaml # type: ignore from jnpr.junos import Device # type: ignore from jnpr.junos.utils.config import Config # type: ignore def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Build connection, template config, and push to device. Loop over our list of routers that we imported from inventory.py Utilize the ID as the last octet within the IP address of the router Once the connection is open, print a message to the console Ingest the configuration variables stored in our device's' YAML file \"\"\" for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) dev . open () print ( f \"connected to { each [ 'name' ] } \" ) # noqa T001 \"\"\" creating an empty dictionary called `data` then stuffing our YAML vars into it as 'configuration' this is to help handle PyEZ loading YAML vars differently than Jinja2 \"\"\" data = dict () data [ \"configuration\" ] = yaml . safe_load ( open ( f \"vars/ { each [ 'name' ] } .yaml\" )) configuration = Config ( dev ) configuration . load ( template_path = \"templates/junos.j2\" , template_vars = data , format = \"set\" ) configuration . pdiff () if configuration . commit_check (): configuration . commit () else : configuration . rollback () dev . close () if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices. \"\"\" devices = inventory () main ( devices ) \ud83d\udcf8 Screenshots","title":"configure.py"},{"location":"docs/automation/configure.py/#overview","text":"This script will be ran when you'd like to generate and push a device's configuration using PyEZ.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/configure.py/#files","text":"Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the configure.py script.","title":"\ud83d\udc0d Files"},{"location":"docs/automation/configure.py/#code-deep-dive","text":"","title":"\ud83d\udcdd Code Deep Dive"},{"location":"docs/automation/configure.py/#imports","text":"We will be importing inventory data into our script from a local file named inventory.yaml , so we need to import yaml to handle this functionality. import yaml from jnpr.junos import Device from jnpr.junos.utils.config import Config Two primary functions of PyEZ will be imported, the first of which is the Device object. Device will allow us to model our device's parameters, things like IP address, username, and the sort. But Device will also enable us to build and maintain a NETCONF session to our remote device, so this object Class really does most of the heavy lifting here. From the utilities module, we will be importing the Config class, which will (obviously) handle the configuration aspects of our script.","title":"Imports"},{"location":"docs/automation/configure.py/#configurations","text":"We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter.","title":"Configurations"},{"location":"docs/automation/configure.py/#inventory","text":"We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices .","title":"Inventory"},{"location":"docs/automation/configure.py/#main","text":"For our script's main function, we will loop over our list of routers that we imported from inventory.yaml to open a NETCONF session. def main ( devices ): for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) dev . open () After printing a status message to the console, we will be creating an empty dictionary called data and then stuffing our YAML vars into it as data['configuration'] . The only reason this is here is to help handle the fact that PyEZ and Jinja2 library load YAML vars differently than each other. print ( f \"connected to { each [ 'name' ] } \" ) data = dict () data [ \"configuration\" ] = yaml . safe_load ( open ( f \"vars/ { each [ 'name' ] } .yaml\" )) We pass on the object that represents our device into the Config class, which will create a new object called configuration to represent our device's configuration. configuration = Config ( dev ) configuration . load ( template_path = \"templates/junos.j2\" , template_vars = data , format = \"set\" ) Next we see that we run the load method of our recently created configuration object, and we pass it three options: Point to our Jinja2 template file at templates/junos.j2 Point to our device's variables (the data object created above) Declare that our configuration is in the set format, alternatives would be text , xml , or json This will push the device's configuration to the candidate config database, but will not commit it just yet. We perform three functions upon the candidate configuration database: Report any configuration diff to the console. Perform a configuration check to make sure our generated configuration is valid. Commit the configuration. configuration . pdiff () if configuration . commit_check (): configuration . commit () else : configuration . rollback () dev . close () Should the configuration fail the configuration check, roll back to the previous state. Close our NETCONF session.","title":"main()"},{"location":"docs/automation/configure.py/#initialize","text":"There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. if __name__ == \"__main__\" : devices = inventory () main ( devices ) We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices.","title":"Initialize"},{"location":"docs/automation/configure.py/#workflow","text":"Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python configure.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke configure","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/configure.py/#script","text":"\"\"\"Generate production configurations and push to our network devices.\"\"\" import yaml # type: ignore from jnpr.junos import Device # type: ignore from jnpr.junos.utils.config import Config # type: ignore def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Build connection, template config, and push to device. Loop over our list of routers that we imported from inventory.py Utilize the ID as the last octet within the IP address of the router Once the connection is open, print a message to the console Ingest the configuration variables stored in our device's' YAML file \"\"\" for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) dev . open () print ( f \"connected to { each [ 'name' ] } \" ) # noqa T001 \"\"\" creating an empty dictionary called `data` then stuffing our YAML vars into it as 'configuration' this is to help handle PyEZ loading YAML vars differently than Jinja2 \"\"\" data = dict () data [ \"configuration\" ] = yaml . safe_load ( open ( f \"vars/ { each [ 'name' ] } .yaml\" )) configuration = Config ( dev ) configuration . load ( template_path = \"templates/junos.j2\" , template_vars = data , format = \"set\" ) configuration . pdiff () if configuration . commit_check (): configuration . commit () else : configuration . rollback () dev . close () if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices. \"\"\" devices = inventory () main ( devices )","title":"\ud83d\udc0d Script"},{"location":"docs/automation/configure.py/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/dockerfile/","text":"Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. \ud83d\ude80 Building the Docker container image The workflow will depend on whether or not you're taking advantage of Invoke. Without Invoke Build the container image locally requires just a single command, make sure to update the name of your image from xyz to whatever works for your team. docker build -t xyz:latest files/docker/ With Invoke For those that created a virtual environment with Poetry, we have provided a couple of additional Invoke tasks below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. FWIW, all tasks within Invoke's tasks.py file are tied to Docker containers. \ud83d\ude80 Building the Docker container image The workflow will depend on whether or not you're taking advantage of Invoke. With Invoke Command Action invoke shell Get access to the BASH shell within our container. Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Build Docker container image (one-time operation) Run locally or within a container using the Invoke package invoke shell","title":"Dockerfile"},{"location":"docs/automation/dockerfile/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment.","title":"Dockerfile"},{"location":"docs/automation/dockerfile/#building-the-docker-container-image","text":"The workflow will depend on whether or not you're taking advantage of Invoke.","title":"\ud83d\ude80 Building the Docker container image"},{"location":"docs/automation/dockerfile/#without-invoke","text":"Build the container image locally requires just a single command, make sure to update the name of your image from xyz to whatever works for your team. docker build -t xyz:latest files/docker/","title":"Without Invoke"},{"location":"docs/automation/dockerfile/#with-invoke","text":"For those that created a virtual environment with Poetry, we have provided a couple of additional Invoke tasks below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. FWIW, all tasks within Invoke's tasks.py file are tied to Docker containers.","title":"With Invoke"},{"location":"docs/automation/dockerfile/#building-the-docker-container-image_1","text":"The workflow will depend on whether or not you're taking advantage of Invoke.","title":"\ud83d\ude80 Building the Docker container image"},{"location":"docs/automation/dockerfile/#with-invoke_1","text":"Command Action invoke shell Get access to the BASH shell within our container. Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Build Docker container image (one-time operation) Run locally or within a container using the Invoke package invoke shell","title":"With Invoke"},{"location":"docs/automation/generate.py/","text":"\ud83d\udccc Overview This script is used when your goal is to just generate the configurations locally. PyEZ would not be the best candidate in this setup, as it's ability to generate template configurations is based upon a connection to a device. Instead we will be using the same Jinja2 templating engine, just outside of PyEZ. Configurations will be stored in a local directory, as declared within our script below. \ud83d\udc0d Files Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the generate.py script. \ud83d\udcdd Code Deep Dive Imports We will be using the same inventory.yaml file used in our PyEZ configuration task, so we will need to import the ability to read YAML here. import yaml # type: ignore from jinja2 import Environment , FileSystemLoader Jinja2 has a couple components that we'll use here, Environment : configuration options and template functionality FileSystemLoader : allows us to declare the path of our working directory Configurations We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter. Inventory We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices . Output Directory We will want to tell Jinja2 where we expect it to output the templated configurations. Setting it up here as a constant is simply out of convenience. CONFIG_PATH = \"./configurations/generated\" Jinja2 Options Jinja2 has many options, here we will just focus on some of the more common ones. The FileSystemLoader was imported at the top of our script from Jinja2, and it will help us when writting to the local system. Its sole parameter passed references the path that Jinja2 should reference. We create a new object called env and set it equal to an instance of the Environment class we imported from Jinja2, and passing it our recently-created file_loader object. When autoescaping is enabled, Jinja2 will filter input strings to escape any HTML content submitted via template variables. Without escaping HTML input the application becomes vulnerable to Cross Site Scripting (XSS) attacks. file_loader = FileSystemLoader ( \"./\" ) env = Environment ( loader = file_loader , autoescape = True ) env . trim_blocks = True env . lstrip_blocks = True trim_blocks : If this is set to True the first newline after a block is removed. lstrip_blocks : If this is set to True leading spaces and tabs are stripped from the start of a line to a block. Device Variables Jinja requires two things to complete its work: a template file and variables to run through it. Here we will loop over the devices that are found within the routers group of our inventory.yaml file. For each entry in our list, we will look for a variable file in the vars/ directory. The name of the file will be based upon our device's hostname, which again was sourced from our devices object. for each in devices [ \"routers\" ]: with open ( f \"vars/ { each [ 'name' ] } .yaml\" , \"r\" ) as stream : The contents of our device's variables will be referenced as stream in the next steps below. main() This is the primary function of our script. Here will find us setting up our Jinja2 environment and running our device's variable file through the configuration template. When the main function is called in our if __name__ == \"__main__\": below, it will be passed the output of our inventory function described above. We will use this list of devices to loop over when generating our configurations. def main ( devices ): Build configurations With our device's configuration variables loaded into an object called stream , we will safely load the YAML file's contents into a python dictionary called variables . Creating a new object called template and setting it equal an instance of Jinja2's get_template() method, and making sure to tell it where to find our template file. Finally, we build our configuration by running our variables object through the render method, and storing the output as output . try : variables = yaml . safe_load ( stream ) template = env . get_template ( \"templates/junos.j2\" ) output = template . render ( configuration = variables ) # execution goes here. except yaml . YAMLError as exc : print ( exc ) We wrap this all up within a Try/Except clause, enabling us to halt execution and print a message when there's an error with our YAML Writing to a local file At this point, our generated configuration lives within Python as an object, this step will find us writing this to a local file. We open a file for our device's configuration based upon its name, but we need to perform a little cleanup before we write anything. A Jinja2 generated configuration will have a lot of blank lines for various reasons, we want to get rid of these blank lines to make it easier to read our configurations. So we loop over each line within our object and perform a strip() operation upon it. Only lines with text within them will then be written to our file, with a \\n to create a new line break after each line. with open ( f \" { CONFIG_PATH } / { each [ 'name' ] } .conf\" , \"w\" ) as f : for line in output . splitlines (): cleanedLine = line . strip () if cleanedLine : f . write ( cleanedLine + str ( \" \\n \" )) print ( f \"config built: { CONFIG_PATH } / { each [ 'name' ] } .conf\" ) Finally we see a print statement on the console, informing us of our success and where to find the configurations. Initialize script We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the templating a local copy of our configurations. if __name__ == \"__main__\" : devices = inventory () main ( devices ) \ud83d\ude80 Workflow Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python generate.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke generate \ud83d\udcf8 Screenshots \ud83d\udc0d Script \"\"\"Generate bootstrap configurations for our network devices.\"\"\" import yaml # type: ignore from jinja2 import Environment , FileSystemLoader # define Jinja2 environment CONFIG_PATH = \"./configurations/generated\" def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Template configuration with Jinja2 and store locally.\"\"\" # set up our Jinja2 environment file_loader = FileSystemLoader ( \"./\" ) env = Environment ( loader = file_loader , autoescape = True ) env . trim_blocks = True env . lstrip_blocks = True # begin loop over devices for each in devices [ \"routers\" ]: # create a template based on variables stored in file with open ( f \"vars/ { each [ 'name' ] } .yaml\" , \"r\" ) as stream : try : # set up our environment and render configuration variables = yaml . safe_load ( stream ) template = env . get_template ( \"templates/junos.j2\" ) output = template . render ( configuration = variables ) # write our rendered configuration to a local file with open ( f \" { CONFIG_PATH } / { each [ 'name' ] } .conf\" , \"w\" ) as f : for line in output . splitlines (): cleanedLine = line . strip () if cleanedLine : f . write ( cleanedLine + str ( \" \\n \" )) print ( f \"config built: { CONFIG_PATH } / { each [ 'name' ] } .conf\" ) # noqa T001 except yaml . YAMLError as exc : print ( exc ) # noqa T001 if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices. \"\"\" devices = inventory () main ( devices )","title":"generate.py"},{"location":"docs/automation/generate.py/#overview","text":"This script is used when your goal is to just generate the configurations locally. PyEZ would not be the best candidate in this setup, as it's ability to generate template configurations is based upon a connection to a device. Instead we will be using the same Jinja2 templating engine, just outside of PyEZ. Configurations will be stored in a local directory, as declared within our script below.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/generate.py/#files","text":"Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the generate.py script.","title":"\ud83d\udc0d Files"},{"location":"docs/automation/generate.py/#code-deep-dive","text":"","title":"\ud83d\udcdd Code Deep Dive"},{"location":"docs/automation/generate.py/#imports","text":"We will be using the same inventory.yaml file used in our PyEZ configuration task, so we will need to import the ability to read YAML here. import yaml # type: ignore from jinja2 import Environment , FileSystemLoader Jinja2 has a couple components that we'll use here, Environment : configuration options and template functionality FileSystemLoader : allows us to declare the path of our working directory","title":"Imports"},{"location":"docs/automation/generate.py/#configurations","text":"We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter.","title":"Configurations"},{"location":"docs/automation/generate.py/#inventory","text":"We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices .","title":"Inventory"},{"location":"docs/automation/generate.py/#output-directory","text":"We will want to tell Jinja2 where we expect it to output the templated configurations. Setting it up here as a constant is simply out of convenience. CONFIG_PATH = \"./configurations/generated\"","title":"Output Directory"},{"location":"docs/automation/generate.py/#jinja2-options","text":"Jinja2 has many options, here we will just focus on some of the more common ones. The FileSystemLoader was imported at the top of our script from Jinja2, and it will help us when writting to the local system. Its sole parameter passed references the path that Jinja2 should reference. We create a new object called env and set it equal to an instance of the Environment class we imported from Jinja2, and passing it our recently-created file_loader object. When autoescaping is enabled, Jinja2 will filter input strings to escape any HTML content submitted via template variables. Without escaping HTML input the application becomes vulnerable to Cross Site Scripting (XSS) attacks. file_loader = FileSystemLoader ( \"./\" ) env = Environment ( loader = file_loader , autoescape = True ) env . trim_blocks = True env . lstrip_blocks = True trim_blocks : If this is set to True the first newline after a block is removed. lstrip_blocks : If this is set to True leading spaces and tabs are stripped from the start of a line to a block.","title":"Jinja2 Options"},{"location":"docs/automation/generate.py/#device-variables","text":"Jinja requires two things to complete its work: a template file and variables to run through it. Here we will loop over the devices that are found within the routers group of our inventory.yaml file. For each entry in our list, we will look for a variable file in the vars/ directory. The name of the file will be based upon our device's hostname, which again was sourced from our devices object. for each in devices [ \"routers\" ]: with open ( f \"vars/ { each [ 'name' ] } .yaml\" , \"r\" ) as stream : The contents of our device's variables will be referenced as stream in the next steps below.","title":"Device Variables"},{"location":"docs/automation/generate.py/#main","text":"This is the primary function of our script. Here will find us setting up our Jinja2 environment and running our device's variable file through the configuration template. When the main function is called in our if __name__ == \"__main__\": below, it will be passed the output of our inventory function described above. We will use this list of devices to loop over when generating our configurations. def main ( devices ):","title":"main()"},{"location":"docs/automation/generate.py/#build-configurations","text":"With our device's configuration variables loaded into an object called stream , we will safely load the YAML file's contents into a python dictionary called variables . Creating a new object called template and setting it equal an instance of Jinja2's get_template() method, and making sure to tell it where to find our template file. Finally, we build our configuration by running our variables object through the render method, and storing the output as output . try : variables = yaml . safe_load ( stream ) template = env . get_template ( \"templates/junos.j2\" ) output = template . render ( configuration = variables ) # execution goes here. except yaml . YAMLError as exc : print ( exc ) We wrap this all up within a Try/Except clause, enabling us to halt execution and print a message when there's an error with our YAML","title":"Build configurations"},{"location":"docs/automation/generate.py/#writing-to-a-local-file","text":"At this point, our generated configuration lives within Python as an object, this step will find us writing this to a local file. We open a file for our device's configuration based upon its name, but we need to perform a little cleanup before we write anything. A Jinja2 generated configuration will have a lot of blank lines for various reasons, we want to get rid of these blank lines to make it easier to read our configurations. So we loop over each line within our object and perform a strip() operation upon it. Only lines with text within them will then be written to our file, with a \\n to create a new line break after each line. with open ( f \" { CONFIG_PATH } / { each [ 'name' ] } .conf\" , \"w\" ) as f : for line in output . splitlines (): cleanedLine = line . strip () if cleanedLine : f . write ( cleanedLine + str ( \" \\n \" )) print ( f \"config built: { CONFIG_PATH } / { each [ 'name' ] } .conf\" ) Finally we see a print statement on the console, informing us of our success and where to find the configurations.","title":"Writing to a local file"},{"location":"docs/automation/generate.py/#initialize-script","text":"We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the templating a local copy of our configurations. if __name__ == \"__main__\" : devices = inventory () main ( devices )","title":"Initialize script"},{"location":"docs/automation/generate.py/#workflow","text":"Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python generate.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke generate","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/generate.py/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/generate.py/#script","text":"\"\"\"Generate bootstrap configurations for our network devices.\"\"\" import yaml # type: ignore from jinja2 import Environment , FileSystemLoader # define Jinja2 environment CONFIG_PATH = \"./configurations/generated\" def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Template configuration with Jinja2 and store locally.\"\"\" # set up our Jinja2 environment file_loader = FileSystemLoader ( \"./\" ) env = Environment ( loader = file_loader , autoescape = True ) env . trim_blocks = True env . lstrip_blocks = True # begin loop over devices for each in devices [ \"routers\" ]: # create a template based on variables stored in file with open ( f \"vars/ { each [ 'name' ] } .yaml\" , \"r\" ) as stream : try : # set up our environment and render configuration variables = yaml . safe_load ( stream ) template = env . get_template ( \"templates/junos.j2\" ) output = template . render ( configuration = variables ) # write our rendered configuration to a local file with open ( f \" { CONFIG_PATH } / { each [ 'name' ] } .conf\" , \"w\" ) as f : for line in output . splitlines (): cleanedLine = line . strip () if cleanedLine : f . write ( cleanedLine + str ( \" \\n \" )) print ( f \"config built: { CONFIG_PATH } / { each [ 'name' ] } .conf\" ) # noqa T001 except yaml . YAMLError as exc : print ( exc ) # noqa T001 if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the templating and pushing of our configurations to the remote devices. \"\"\" devices = inventory () main ( devices )","title":"\ud83d\udc0d Script"},{"location":"docs/automation/invoke/","text":"\ud83d\udccc Overview You will find a packaged called Invoke installed within your poetry's virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Build Docker container image (one-time operation) Access the container's bash shell for running scripts without Invoke Configure your MPLS network poetry install poetry shell invoke build invoke shell invoke configure \ud83d\udcf8 Screenshots","title":"Invoke"},{"location":"docs/automation/invoke/#overview","text":"You will find a packaged called Invoke installed within your poetry's virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/invoke/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Build Docker container image (one-time operation) Access the container's bash shell for running scripts without Invoke Configure your MPLS network poetry install poetry shell invoke build invoke shell invoke configure","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/invoke/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/overview/","text":"\ud83d\udccc Overview Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations. \ud83d\udc0d Files All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Python Scripts You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy. Inventory file The inventory.yaml file stores information about our devices, basic information like hostname and IP address. configurations/ directory If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations. templates/ directory Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory. vars/ directory Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations. \ud83d\udee0\ufe0f Tools In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project. Poetry A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. Invoke You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"Overview"},{"location":"docs/automation/overview/#overview","text":"Our primary goal today is to use PyEZ to provision eight Juniper vMX routers into various elements of an MPLS network. While PyEZ has the capability of pushing individual lines, or groups of lines, of configurations to a device, here we will be building and pushing an entire configuration. We will also be following the guiding principles of Infrastructure-as-Code , where we will store our the elements of our configuration as YAML, to be ran through a Jinja2 template to output our configurations.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/overview/#files","text":"All of our project's scripts, variables, and template files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py","title":"\ud83d\udc0d Files"},{"location":"docs/automation/overview/#python-scripts","text":"You likely don't need me to explain that the files that end with .py are the various Python scripts. Here is a quick glimpse into the four provided. Script Action generate.py Build the configurations locally with Jinaj2. configure.py Build and push our configurations with PyEZ. download.py Download our configurations with PyEZ. rollback.py Rollback to our bootstrap configurations with PyEZ. validate.py Validate our MPLS L3VPN circuit with JSNAPy.","title":"Python Scripts"},{"location":"docs/automation/overview/#inventory-file","text":"The inventory.yaml file stores information about our devices, basic information like hostname and IP address.","title":"Inventory file"},{"location":"docs/automation/overview/#configurations-directory","text":"If you choose to generate the configurations locally but not push them to the devices, then you will find the generated configurations within the configurations directory. I had also included the working final configurations in this directory if you just want to see the resulting configurations.","title":"configurations/ directory"},{"location":"docs/automation/overview/#templates-directory","text":"Since we are storing our configuration as code, we will need some kind of templating engine to run our variables through to produce the configurations. For this we have Jinja2 to handle the templating, and its template files are stored in the templates directory.","title":"templates/ directory"},{"location":"docs/automation/overview/#vars-directory","text":"Finally, the device's configuration will be stored as YAML files found within the vars/ directory. Each device will have its own file to represent its configuration. We will run these files through the Jinaj2 templates to produce our configurations.","title":"vars/ directory"},{"location":"docs/automation/overview/#tools","text":"In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project.","title":"\ud83d\udee0\ufe0f Tools"},{"location":"docs/automation/overview/#poetry","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"Poetry"},{"location":"docs/automation/overview/#invoke","text":"You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"Invoke"},{"location":"docs/automation/overview/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Dockerfile"},{"location":"docs/automation/overview/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Run locally or within a container using the Invoke package poetry install poetry shell invoke configure","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/poetry/","text":"\ud83d\udccc Overview A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. \ud83d\ude80 Workflow The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Validate the Python packages installed poetry install poetry shell pip freeze","title":"Poetry"},{"location":"docs/automation/poetry/#overview","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/poetry/#workflow","text":"The workflow will look like this: Have Poetry install your Python packages in a virtual environment (one-time operation) Activate your new virtual environment with Poetry Validate the Python packages installed poetry install poetry shell pip freeze","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/rollback.py/","text":"\ud83d\udccc Overview This script will be ran when you'd like to use PyEZ to roll a device's configuration back to the previous configuration. \ud83d\udc0d Files Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the rollback.py script. \ud83d\udcdd Code Deep Dive Imports We will be importing inventory data into our script from a local file named inventory.yaml , so we need to import yaml to handle this functionality. import yaml from jnpr.junos import Device from jnpr.junos.exception import CommitError from jnpr.junos.exception import ConnectError from jnpr.junos.exception import LockError from jnpr.junos.exception import RpcError from jnpr.junos.exception import UnlockError from jnpr.junos.utils.config import Config Two primary functions of PyEZ will be imported, the first of which is the Device object. Device will allow us to model our device's parameters, things like IP address, username, and the sort. But Device will also enable us to build and maintain a NETCONF session to our remote device, so this object Class really does most of the heavy lifting here. From the utilities module, we will be importing the Config class, which will (obviously) handle the configuration aspects of our script. Several problems could arise within this request, so we import PyEZ's error types to help us validate that everything either worked or failed safely. Configurations We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter. Inventory We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices . main() For our script's main function, we will loop over our list of routers that we imported from inventory.yaml to open a NETCONF session. def main ( devices ): for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) try : dev . open () print ( f \"connected to { each [ 'name' ] } \" ) except ConnectError as err : print ( f \"Cannot connect to { each [ 'name' ] } : { err } \" ) return Create an object based on the Config object type, passing it our connection to the device. Perform a lock on the configuration database, perform the rollback, and commit. configuration = Config ( dev ) print ( \"Locking the configuration\" ) try : configuration . lock () except LockError as err : print ( f \"Unable to lock configuration: { err } \" ) dev . close () return try : print ( \"Rolling back the configuration\" ) configuration . rollback ( rb_id = 1 ) print ( \"Committing the configuration\" ) configuration . commit () except CommitError as err : print ( f \"Error: Unable to commit configuration: { err } \" ) except RpcError as err : print ( f \"Unable to roll back configuration changes: { err } \" ) print ( \"Unlocking the configuration\" ) try : configuration . unlock () except UnlockError as err : print ( f \"Unable to unlock configuration: { err } \" ) dev . close () Unlock the configuration database and close our NETCONF session. Initialize script There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. if __name__ == \"__main__\" : devices = inventory () main ( devices ) We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the logging into and performing a rollback upon the remote devices. \ud83d\ude80 Workflow Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python rollback.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke rollback \ud83d\udcf8 Screenshots \ud83d\udc0d Script \"\"\"rollback.py: perform a 'rollback 1' operation on our network devices.\"\"\" import yaml # type: ignore from jnpr.junos import Device # type: ignore from jnpr.junos.exception import CommitError # type: ignore from jnpr.junos.exception import ConnectError # type: ignore from jnpr.junos.exception import LockError # type: ignore from jnpr.junos.exception import RpcError # type: ignore from jnpr.junos.exception import UnlockError # type: ignore from jnpr.junos.utils.config import Config # type: ignore def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Rollback the configuration to the previous state. Loop over our list of routers that we imported from inventory.py Utilize the ID as the last octet within the IP address of the router Once the connection is open, perform the following steps 1. Print a message to the console 2. Perform a \"lock\" on the configuration 3. Rollback to the previous state 4. Commit the configuration 5. Perform an \"unlock\" on the configuration 6. Gracefully exit the NETCONF session Various error handling mechanisms have been included to ensure that the operator safely exits the script when a known failure occurs. \"\"\" for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) try : dev . open () print ( f \"connected to { each [ 'name' ] } \" ) # noqa T001 except ConnectError as err : print ( f \"Cannot connect to { each [ 'name' ] } : { err } \" ) # noqa T001 return configuration = Config ( dev ) # Lock the configuration print ( \"Locking the configuration\" ) # noqa T001 try : configuration . lock () except LockError as err : print ( f \"Unable to lock configuration: { err } \" ) dev . close () return try : print ( \"Rolling back the configuration\" ) # noqa T001 configuration . rollback ( rb_id = 1 ) print ( \"Committing the configuration\" ) # noqa T001 configuration . commit () except CommitError as err : print ( f \"Error: Unable to commit configuration: { err } \" ) # noqa T001 except RpcError as err : print ( f \"Unable to roll back configuration changes: { err } \" ) # noqa T001 print ( \"Unlocking the configuration\" ) # noqa T001 try : configuration . unlock () except UnlockError as err : print ( f \"Unable to unlock configuration: { err } \" ) # noqa T001 dev . close () if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the rolling back the configurations on the remote devices. \"\"\" devices = inventory () main ( devices )","title":"rollback.py"},{"location":"docs/automation/rollback.py/#overview","text":"This script will be ran when you'd like to use PyEZ to roll a device's configuration back to the previous configuration.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/rollback.py/#files","text":"Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the rollback.py script.","title":"\ud83d\udc0d Files"},{"location":"docs/automation/rollback.py/#code-deep-dive","text":"","title":"\ud83d\udcdd Code Deep Dive"},{"location":"docs/automation/rollback.py/#imports","text":"We will be importing inventory data into our script from a local file named inventory.yaml , so we need to import yaml to handle this functionality. import yaml from jnpr.junos import Device from jnpr.junos.exception import CommitError from jnpr.junos.exception import ConnectError from jnpr.junos.exception import LockError from jnpr.junos.exception import RpcError from jnpr.junos.exception import UnlockError from jnpr.junos.utils.config import Config Two primary functions of PyEZ will be imported, the first of which is the Device object. Device will allow us to model our device's parameters, things like IP address, username, and the sort. But Device will also enable us to build and maintain a NETCONF session to our remote device, so this object Class really does most of the heavy lifting here. From the utilities module, we will be importing the Config class, which will (obviously) handle the configuration aspects of our script. Several problems could arise within this request, so we import PyEZ's error types to help us validate that everything either worked or failed safely.","title":"Imports"},{"location":"docs/automation/rollback.py/#configurations","text":"We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter.","title":"Configurations"},{"location":"docs/automation/rollback.py/#inventory","text":"We are declaring our device inventory in a YAML markdown, since YAML is easy for humans and powerful for machines. def inventory (): devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices Here we are taking advantage of the yaml library we imported and calling the safe_load method to load in the data from our inventory.yaml file. The function returns our list of devices as an object called devices .","title":"Inventory"},{"location":"docs/automation/rollback.py/#main","text":"For our script's main function, we will loop over our list of routers that we imported from inventory.yaml to open a NETCONF session. def main ( devices ): for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) try : dev . open () print ( f \"connected to { each [ 'name' ] } \" ) except ConnectError as err : print ( f \"Cannot connect to { each [ 'name' ] } : { err } \" ) return Create an object based on the Config object type, passing it our connection to the device. Perform a lock on the configuration database, perform the rollback, and commit. configuration = Config ( dev ) print ( \"Locking the configuration\" ) try : configuration . lock () except LockError as err : print ( f \"Unable to lock configuration: { err } \" ) dev . close () return try : print ( \"Rolling back the configuration\" ) configuration . rollback ( rb_id = 1 ) print ( \"Committing the configuration\" ) configuration . commit () except CommitError as err : print ( f \"Error: Unable to commit configuration: { err } \" ) except RpcError as err : print ( f \"Unable to roll back configuration changes: { err } \" ) print ( \"Unlocking the configuration\" ) try : configuration . unlock () except UnlockError as err : print ( f \"Unable to unlock configuration: { err } \" ) dev . close () Unlock the configuration database and close our NETCONF session.","title":"main()"},{"location":"docs/automation/rollback.py/#initialize-script","text":"There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. if __name__ == \"__main__\" : devices = inventory () main ( devices ) We will first load our inventory.yaml file into a new Python object devices . Our main function will run next, which will take care of the logging into and performing a rollback upon the remote devices.","title":"Initialize script"},{"location":"docs/automation/rollback.py/#workflow","text":"Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python rollback.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke rollback","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/rollback.py/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/rollback.py/#script","text":"\"\"\"rollback.py: perform a 'rollback 1' operation on our network devices.\"\"\" import yaml # type: ignore from jnpr.junos import Device # type: ignore from jnpr.junos.exception import CommitError # type: ignore from jnpr.junos.exception import ConnectError # type: ignore from jnpr.junos.exception import LockError # type: ignore from jnpr.junos.exception import RpcError # type: ignore from jnpr.junos.exception import UnlockError # type: ignore from jnpr.junos.utils.config import Config # type: ignore def inventory (): \"\"\"Load our inventory.yaml into a python object called routers.\"\"\" devices = yaml . safe_load ( open ( \"inventory.yaml\" )) return devices def main ( devices ): \"\"\"Rollback the configuration to the previous state. Loop over our list of routers that we imported from inventory.py Utilize the ID as the last octet within the IP address of the router Once the connection is open, perform the following steps 1. Print a message to the console 2. Perform a \"lock\" on the configuration 3. Rollback to the previous state 4. Commit the configuration 5. Perform an \"unlock\" on the configuration 6. Gracefully exit the NETCONF session Various error handling mechanisms have been included to ensure that the operator safely exits the script when a known failure occurs. \"\"\" for each in devices [ \"routers\" ]: dev = Device ( host = f \" { each [ 'ip' ] } \" , user = \"jcluser\" , password = \"Juniper!1\" , gather_facts = False , ) try : dev . open () print ( f \"connected to { each [ 'name' ] } \" ) # noqa T001 except ConnectError as err : print ( f \"Cannot connect to { each [ 'name' ] } : { err } \" ) # noqa T001 return configuration = Config ( dev ) # Lock the configuration print ( \"Locking the configuration\" ) # noqa T001 try : configuration . lock () except LockError as err : print ( f \"Unable to lock configuration: { err } \" ) dev . close () return try : print ( \"Rolling back the configuration\" ) # noqa T001 configuration . rollback ( rb_id = 1 ) print ( \"Committing the configuration\" ) # noqa T001 configuration . commit () except CommitError as err : print ( f \"Error: Unable to commit configuration: { err } \" ) # noqa T001 except RpcError as err : print ( f \"Unable to roll back configuration changes: { err } \" ) # noqa T001 print ( \"Unlocking the configuration\" ) # noqa T001 try : configuration . unlock () except UnlockError as err : print ( f \"Unable to unlock configuration: { err } \" ) # noqa T001 dev . close () if __name__ == \"__main__\" : \"\"\"Main script execution. We will first load our inventory.yaml file into a new Python object `devices` Our main function will run next, which will take care of the rolling back the configurations on the remote devices. \"\"\" devices = inventory () main ( devices )","title":"\ud83d\udc0d Script"},{"location":"docs/automation/tools/","text":"\ud83d\udccc Overview In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project. Poetry A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it. Invoke You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy. Dockerfile A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Tools"},{"location":"docs/automation/tools/#overview","text":"In hopes to making this project as easy as possible to execute, I have provided many tools to help with execution of the tasks within this project.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/tools/#poetry","text":"A Poetry lock file to help you create a Python environment that mirrors my own. As long as you have Poetry installed on your machine , to you can simply type poetry install to create the virtual environment, followed by poetry shell to activate it.","title":"Poetry"},{"location":"docs/automation/tools/#invoke","text":"You will find a packaged called Invoke installed within the virtual environment. Invoke is an elegant way to create CLI shortcuts for commands that are long to type out. Here is a short list of some of the Invoke operations created in the tasks.py file. Command Action invoke generate Build the configurations locally with Jinaj2. invoke configure Build and push our configurations with PyEZ. invoke download Download our configurations with PyEZ. invoke rollback Rollback to our bootstrap configurations with PyEZ. invoke validate Validate our MPLS L3VPN circuit with JSNAPy.","title":"Invoke"},{"location":"docs/automation/tools/#dockerfile","text":"A Dockerfile has also been provided for those that would like to execute this within an isolated container instead of a virtual environment. A couple of additional Invoke tasks are listed below to help with building and accessing the Docker container environment. Command Action invoke build Build an instance of the Docker container image locally. invoke shell Get access to the BASH shell within our container.","title":"Dockerfile"},{"location":"docs/automation/validate/","text":"\ud83d\udccc Overview Our goal here is to use JSNAPy to validate the route table information within our provisioned fabric. \ud83d\udc0d Files Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the validate.py script and its associated JSNAPy test file tests/test_l3vpn_routes.yaml . validate.py Starting off with our imports, let's explain what we're bringing into this script and why. \"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin We see that we are bringing in the core python library os , this will be used very soon to help us figure out what the full path of our python script is. Our additional import is pulling in SnapAdmin from the jnpr.jsnapy library. This will give us a JSNAPy object that will give us the necessary mechanisms to perform snapshots of our production network. Moving on to our configuration elements, let's briefly discuss what these objects do and why we've included them. PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" Remember when I mentioned the need to know the current working path of our python script? This is because we are creating an object called PWD, which will be equal to whatever path the script is executed from. If we executed this script from the /home/skillet/ directory, the value of PWD would be /home/skillet/ . This only matters because we'll need to point JSNAPy to the exact directory of our tests files, or else it'll fall back on the defaults. We create an instance of the SnapAdmin object class we imported from JSNAPy, and we call the new object JSNAPY. From this point forward, when we want to perform a JSNAPy function, we will call this JSNAPY object created here. Finally, our configuration file. This is a simple way of passing a YAML file into JSNAPy without needing an extra YAML file. We instead create a multi-line string in a new object called CONFIG , and within this string we have a YAML file contents. Since JSNAPy is expecting a configuration to be passed as a YAML file, this is a clever way of getting away with not needing another file. And to put the cherry on top, our mechanism of executing the Python script. if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" ) There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. We execute our JSNAPy task by calling our object called JSNAPY , asking it for the snapcheck method, and passing in our CONFIG object (really a multi-line YAML string), and a name for our tests. This will execute JSNAPy with the parameters we have passed within our test file. With such a great segway in place... test_l3vpn_routes.yaml With our attention now on the JSNAPy test file, we will see that we are actually performing two seperate tests on both routers. --- tests_include : - \"route_table_bgp.l3vpn.0\" - \"route_table_Customer1.inet.0\" The tests_include statement allows us an easy way to bundle multiple tests within the same file. Make sure the name of the tests here match an actual test below. Our first test will grab the XML output of the command show route table bgp.l3vpn.0 , which is the L3VPN route table of a PE router. route_table_bgp.l3vpn.0 : - command : \"show route table bgp.l3vpn.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the bgp.l3vpn.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" With the output captured, we iterate over all of the resulting routing tables (should be just 1), and test to see if the value of active-route-count is not equal to the number zero. An informational message and error is provided if this route table exists and is currently zero. Note : the commented out ignore-null: True statement will let the test gracefully skip our assertion if the routing table is not found. We perform a similar test with similar logic against the Customer1.inet.0 routing table, which will make sure we have routes within the customer's VRF. route_table_Customer1.inet.0 : - command : \"show route table Customer1.inet.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the Customer1.inet.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" \ud83d\udcf8 Screenshots","title":"validate"},{"location":"docs/automation/validate/#overview","text":"Our goal here is to use JSNAPy to validate the route table information within our provisioned fabric.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/validate/#files","text":"Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the validate.py script and its associated JSNAPy test file tests/test_l3vpn_routes.yaml .","title":"\ud83d\udc0d Files"},{"location":"docs/automation/validate/#validatepy","text":"Starting off with our imports, let's explain what we're bringing into this script and why. \"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin We see that we are bringing in the core python library os , this will be used very soon to help us figure out what the full path of our python script is. Our additional import is pulling in SnapAdmin from the jnpr.jsnapy library. This will give us a JSNAPy object that will give us the necessary mechanisms to perform snapshots of our production network. Moving on to our configuration elements, let's briefly discuss what these objects do and why we've included them. PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" Remember when I mentioned the need to know the current working path of our python script? This is because we are creating an object called PWD, which will be equal to whatever path the script is executed from. If we executed this script from the /home/skillet/ directory, the value of PWD would be /home/skillet/ . This only matters because we'll need to point JSNAPy to the exact directory of our tests files, or else it'll fall back on the defaults. We create an instance of the SnapAdmin object class we imported from JSNAPy, and we call the new object JSNAPY. From this point forward, when we want to perform a JSNAPy function, we will call this JSNAPY object created here. Finally, our configuration file. This is a simple way of passing a YAML file into JSNAPy without needing an extra YAML file. We instead create a multi-line string in a new object called CONFIG , and within this string we have a YAML file contents. Since JSNAPy is expecting a configuration to be passed as a YAML file, this is a clever way of getting away with not needing another file. And to put the cherry on top, our mechanism of executing the Python script. if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" ) There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. We execute our JSNAPy task by calling our object called JSNAPY , asking it for the snapcheck method, and passing in our CONFIG object (really a multi-line YAML string), and a name for our tests. This will execute JSNAPy with the parameters we have passed within our test file. With such a great segway in place...","title":"validate.py"},{"location":"docs/automation/validate/#test_l3vpn_routesyaml","text":"With our attention now on the JSNAPy test file, we will see that we are actually performing two seperate tests on both routers. --- tests_include : - \"route_table_bgp.l3vpn.0\" - \"route_table_Customer1.inet.0\" The tests_include statement allows us an easy way to bundle multiple tests within the same file. Make sure the name of the tests here match an actual test below. Our first test will grab the XML output of the command show route table bgp.l3vpn.0 , which is the L3VPN route table of a PE router. route_table_bgp.l3vpn.0 : - command : \"show route table bgp.l3vpn.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the bgp.l3vpn.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" With the output captured, we iterate over all of the resulting routing tables (should be just 1), and test to see if the value of active-route-count is not equal to the number zero. An informational message and error is provided if this route table exists and is currently zero. Note : the commented out ignore-null: True statement will let the test gracefully skip our assertion if the routing table is not found. We perform a similar test with similar logic against the Customer1.inet.0 routing table, which will make sure we have routes within the customer's VRF. route_table_Customer1.inet.0 : - command : \"show route table Customer1.inet.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the Customer1.inet.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\"","title":"test_l3vpn_routes.yaml"},{"location":"docs/automation/validate/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/validate.py/","text":"\ud83d\udccc Overview Our goal here is to use JSNAPy to validate the route table information within our provisioned fabric. \ud83d\udc0d Files Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the validate.py script and its associated JSNAPy test file tests/test_l3vpn_routes.yaml . \ud83d\udcdd Code Deep Dive Imports Starting off with our imports, let's explain what we're bringing into this script and why. \"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin We see that we are bringing in the core python library os , this will be used very soon to help us figure out what the full path of our python script is. Our additional import is pulling in SnapAdmin from the jnpr.jsnapy library. This will give us a JSNAPy object that will give us the necessary mechanisms to perform snapshots of our production network. Configurations We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter. JSNAPy parameters Moving on to our configuration elements, let's briefly discuss what these objects do and why we've included them. PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" Remember when I mentioned the need to know the current working path of our python script? This is because we are creating an object called PWD, which will be equal to whatever path the script is executed from. If we executed this script from the /home/skillet/ directory, the value of PWD would be /home/skillet/ . This only matters because we'll need to point JSNAPy to the exact directory of our tests files, or else it'll fall back on the defaults. We create an instance of the SnapAdmin object class we imported from JSNAPy, and we call the new object JSNAPY. From this point forward, when we want to perform a JSNAPy function, we will call this JSNAPY object created here. Finally, our configuration file. This is a simple way of passing a YAML file into JSNAPy without needing an extra YAML file. We instead create a multi-line string in a new object called CONFIG , and within this string we have a YAML file contents. Since JSNAPy is expecting a configuration to be passed as a YAML file, this is a clever way of getting away with not needing another file. JSNAPy Test File With our attention now on the JSNAPy test file https://github.com/cdot65/juniper-mpls-l3vpn-demo/blob/main/files/python/tests/test_l3vpn_routes.yaml , we will see that we are actually performing two seperate tests on both routers. --- tests_include : - \"route_table_bgp.l3vpn.0\" - \"route_table_Customer1.inet.0\" The tests_include statement allows us an easy way to bundle multiple tests within the same file. Make sure the name of the tests here match an actual test below. Our first test will grab the XML output of the command show route table bgp.l3vpn.0 , which is the L3VPN route table of a PE router. route_table_bgp.l3vpn.0 : - command : \"show route table bgp.l3vpn.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the bgp.l3vpn.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" With the output captured, we iterate over all of the resulting routing tables (should be just 1), and test to see if the value of active-route-count is not equal to the number zero. An informational message and error is provided if this route table exists and is currently zero. Note : the commented out ignore-null: True statement will let the test gracefully skip our assertion if the routing table is not found. We perform a similar test with similar logic against the Customer1.inet.0 routing table, which will make sure we have routes within the customer's VRF. route_table_Customer1.inet.0 : - command : \"show route table Customer1.inet.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the Customer1.inet.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" main() This is the primary function of our script. Here will find us setting up our snapcheck to execute against our test file. if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" ) There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. We execute our JSNAPy task by calling our object called JSNAPY , asking it for the snapcheck method, and passing in our CONFIG object (really a multi-line YAML string), and a name for our tests. This will execute JSNAPy with the parameters we have passed within our test file. \ud83d\ude80 Workflow Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python validate.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke validate \ud83d\udcf8 Screenshots \ud83d\udc0d Script \"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" )","title":"validate.py"},{"location":"docs/automation/validate.py/#overview","text":"Our goal here is to use JSNAPy to validate the route table information within our provisioned fabric.","title":"\ud83d\udccc Overview"},{"location":"docs/automation/validate.py/#files","text":"Recall that all of our project's automation files are stored within the files/python directory. files/python \u251c\u2500\u2500 configurations/ \u251c\u2500\u2500 templates/ \u251c\u2500\u2500 tests/ \u251c\u2500\u2500 vars/ \u251c\u2500\u2500 configure.py \u251c\u2500\u2500 download.py \u251c\u2500\u2500 generate.py \u251c\u2500\u2500 inventory.yaml \u251c\u2500\u2500 rollback.py \u2514\u2500\u2500 validate.py Our attention in this section will be upon the validate.py script and its associated JSNAPy test file tests/test_l3vpn_routes.yaml .","title":"\ud83d\udc0d Files"},{"location":"docs/automation/validate.py/#code-deep-dive","text":"","title":"\ud83d\udcdd Code Deep Dive"},{"location":"docs/automation/validate.py/#imports","text":"Starting off with our imports, let's explain what we're bringing into this script and why. \"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin We see that we are bringing in the core python library os , this will be used very soon to help us figure out what the full path of our python script is. Our additional import is pulling in SnapAdmin from the jnpr.jsnapy library. This will give us a JSNAPy object that will give us the necessary mechanisms to perform snapshots of our production network.","title":"Imports"},{"location":"docs/automation/validate.py/#configurations","text":"We will find a need to make adjustments to some of the default behavior of packages, and in some cases create an object to define some parameter.","title":"Configurations"},{"location":"docs/automation/validate.py/#jsnapy-parameters","text":"Moving on to our configuration elements, let's briefly discuss what these objects do and why we've included them. PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" Remember when I mentioned the need to know the current working path of our python script? This is because we are creating an object called PWD, which will be equal to whatever path the script is executed from. If we executed this script from the /home/skillet/ directory, the value of PWD would be /home/skillet/ . This only matters because we'll need to point JSNAPy to the exact directory of our tests files, or else it'll fall back on the defaults. We create an instance of the SnapAdmin object class we imported from JSNAPy, and we call the new object JSNAPY. From this point forward, when we want to perform a JSNAPy function, we will call this JSNAPY object created here. Finally, our configuration file. This is a simple way of passing a YAML file into JSNAPy without needing an extra YAML file. We instead create a multi-line string in a new object called CONFIG , and within this string we have a YAML file contents. Since JSNAPy is expecting a configuration to be passed as a YAML file, this is a clever way of getting away with not needing another file.","title":"JSNAPy parameters"},{"location":"docs/automation/validate.py/#jsnapy-test-file","text":"With our attention now on the JSNAPy test file https://github.com/cdot65/juniper-mpls-l3vpn-demo/blob/main/files/python/tests/test_l3vpn_routes.yaml , we will see that we are actually performing two seperate tests on both routers. --- tests_include : - \"route_table_bgp.l3vpn.0\" - \"route_table_Customer1.inet.0\" The tests_include statement allows us an easy way to bundle multiple tests within the same file. Make sure the name of the tests here match an actual test below. Our first test will grab the XML output of the command show route table bgp.l3vpn.0 , which is the L3VPN route table of a PE router. route_table_bgp.l3vpn.0 : - command : \"show route table bgp.l3vpn.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the bgp.l3vpn.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\" With the output captured, we iterate over all of the resulting routing tables (should be just 1), and test to see if the value of active-route-count is not equal to the number zero. An informational message and error is provided if this route table exists and is currently zero. Note : the commented out ignore-null: True statement will let the test gracefully skip our assertion if the routing table is not found. We perform a similar test with similar logic against the Customer1.inet.0 routing table, which will make sure we have routes within the customer's VRF. route_table_Customer1.inet.0 : - command : \"show route table Customer1.inet.0\" # - ignore-null: True - iterate : xpath : \"//route-table\" id : \"./table-name\" tests : - not-equal : \"active-route-count, 0\" info : \"Validate active routes are found within the Customer1.inet.0 table\" err : \"Route table {{post['table-name']}} has zero active routes\"","title":"JSNAPy Test File"},{"location":"docs/automation/validate.py/#main","text":"This is the primary function of our script. Here will find us setting up our snapcheck to execute against our test file. if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" ) There are thousands of explanations on if __name__ == \"__main__\": within Python, I will rely on your Google skills to find you the one that makes the most sense. In short, we need this so leave it alone. We execute our JSNAPy task by calling our object called JSNAPY , asking it for the snapcheck method, and passing in our CONFIG object (really a multi-line YAML string), and a name for our tests. This will execute JSNAPy with the parameters we have passed within our test file.","title":"main()"},{"location":"docs/automation/validate.py/#workflow","text":"Make sure your Python Virtual Environment has the necessary packages installed. Reminder : a Poetry lock file has been provided to help create your virtual environment to reflect ours. You will need to have Poetry installed . Change into the files/python directory and execute the script cd files/python python validate.py An alternative method of executing the script would be to leverage the Docker container provided with this project. invoke validate","title":"\ud83d\ude80 Workflow"},{"location":"docs/automation/validate.py/#screenshots","text":"","title":"\ud83d\udcf8 Screenshots"},{"location":"docs/automation/validate.py/#script","text":"\"\"\"validate.py: use JSNAPy to validate the L3VPN circuit.\"\"\" import os from jnpr.jsnapy import SnapAdmin PWD = os . path . dirname ( os . path . realpath ( __file__ )) JSNAPY = SnapAdmin () CONFIG = f \"\"\" hosts: - device: 100.123.1.4 username : automation passwd: juniper123 - device: 100.123.1.7 username : automation passwd: juniper123 tests: - { PWD } /tests/test_l3vpn_routes.yaml \"\"\" if __name__ == \"__main__\" : \"\"\"Perform our JSNAPy tests.\"\"\" JSNAPY . snapcheck ( CONFIG , \"test_l3vpn_routes\" )","title":"\ud83d\udc0d Script"},{"location":"docs/lab-environment/juniper-vlabs/","text":"\ud83d\udccc Overview If you're interested in using your access to Juniper's vLabs, we have provided a blueprint named Automation Python MPLS L3VPN Log into Juniper vLabs in your web browser and visit the blueprint . Reserve it for as much time as you need When your topology is up and running, we'll focus our attention on the server labeled \"Automation\". Hover your mouse over the server and a pop-up menu will appear. Selecting SSH from the menu will find your browser jumping into an SSH session with the server. Change into the directory container our project, and perform a git pull operation to make sure you're using the latest copy. There will be a lot of updates, don't worry if the screen fills up. cd automation/juniper-mpls-l3vpn-demo git pull Activate your Python virtual environment by typing poetry shell , follow it with a which python to make sure your python execution path has been updated. poetry shell Before moving on to Invoke, let's compare our inventory file with that of vLabs topology. Make any necessary changes before executing. cat files/python/inventory.yaml","title":"Juniper vLabs"},{"location":"docs/lab-environment/juniper-vlabs/#overview","text":"If you're interested in using your access to Juniper's vLabs, we have provided a blueprint named Automation Python MPLS L3VPN Log into Juniper vLabs in your web browser and visit the blueprint . Reserve it for as much time as you need When your topology is up and running, we'll focus our attention on the server labeled \"Automation\". Hover your mouse over the server and a pop-up menu will appear. Selecting SSH from the menu will find your browser jumping into an SSH session with the server. Change into the directory container our project, and perform a git pull operation to make sure you're using the latest copy. There will be a lot of updates, don't worry if the screen fills up. cd automation/juniper-mpls-l3vpn-demo git pull Activate your Python virtual environment by typing poetry shell , follow it with a which python to make sure your python execution path has been updated. poetry shell Before moving on to Invoke, let's compare our inventory file with that of vLabs topology. Make any necessary changes before executing. cat files/python/inventory.yaml","title":"\ud83d\udccc Overview"},{"location":"docs/lab-environment/local/","text":"\ud83d\udccc Overview To get off the ground running with a local copy of this projects, start with making sure that you have the proper tools instead head of time. Note: If you have EVE-NG running within your home, we have provided a sample EVE-NG lab file . Local Requirements Technology Install Guide Docker install Poetry install Please make sure you have correct permissions to execute Setting up the enviornment Once you're ready for flight, start by cloning this repository to your workstation. git clone https://github.com/cdot65/juniper-mpls-l3vpn-demo.git After changing into the project's directory, create and activate a virtual environment with Poetry cd juniper-mpls-l3vpn-demo.git poetry install poetry shell","title":"Local"},{"location":"docs/lab-environment/local/#overview","text":"To get off the ground running with a local copy of this projects, start with making sure that you have the proper tools instead head of time. Note: If you have EVE-NG running within your home, we have provided a sample EVE-NG lab file .","title":"\ud83d\udccc Overview"},{"location":"docs/lab-environment/local/#local-requirements","text":"Technology Install Guide Docker install Poetry install Please make sure you have correct permissions to execute","title":"Local Requirements"},{"location":"docs/lab-environment/local/#setting-up-the-enviornment","text":"Once you're ready for flight, start by cloning this repository to your workstation. git clone https://github.com/cdot65/juniper-mpls-l3vpn-demo.git After changing into the project's directory, create and activate a virtual environment with Poetry cd juniper-mpls-l3vpn-demo.git poetry install poetry shell","title":"Setting up the enviornment"},{"location":"docs/network/ip/","text":"\ud83d\udccc Overview This section explains our default IPv4 address schema IP Addressing Each router will be given an ID of 11-17, and its loopback/router-id will be built upon it within the prefix of 192.168.255.{x}/32 , where {x} represents the local device's ID. Additionally, P2P connections will follow a pattern of 10.{x}.{y}.{x}/24 , where {x} represents the local device's ID and {y} represents the ID of the remote router. Examples Example files have been included to help explain Router1 loopback0 = \"192.168.255.11\" router id = \"192.168.255.11\" p2p to router2 = \"10.11.12.11/24\" p2p to router3 = \"10.11.13.11/24\" p2p to router5 = \"10.11.15.11/24\" Router2 loopback0 = \"192.168.255.12\" router id = \"192.168.255.12\" p2p to router2 = \"10.11.12.12/24\" p2p to router3 = \"10.12.13.12/24\" p2p to router5 = \"10.12.15.12/24\"","title":"IP Schema"},{"location":"docs/network/ip/#overview","text":"This section explains our default IPv4 address schema","title":"\ud83d\udccc Overview"},{"location":"docs/network/ip/#ip-addressing","text":"Each router will be given an ID of 11-17, and its loopback/router-id will be built upon it within the prefix of 192.168.255.{x}/32 , where {x} represents the local device's ID. Additionally, P2P connections will follow a pattern of 10.{x}.{y}.{x}/24 , where {x} represents the local device's ID and {y} represents the ID of the remote router.","title":"IP Addressing"},{"location":"docs/network/ip/#examples","text":"Example files have been included to help explain","title":"Examples"},{"location":"docs/network/ip/#router1","text":"loopback0 = \"192.168.255.11\" router id = \"192.168.255.11\" p2p to router2 = \"10.11.12.11/24\" p2p to router3 = \"10.11.13.11/24\" p2p to router5 = \"10.11.15.11/24\"","title":"Router1"},{"location":"docs/network/ip/#router2","text":"loopback0 = \"192.168.255.12\" router id = \"192.168.255.12\" p2p to router2 = \"10.11.12.12/24\" p2p to router3 = \"10.12.13.12/24\" p2p to router5 = \"10.12.15.12/24\"","title":"Router2"},{"location":"docs/network/mpls/","text":"\ud83d\udccc Overview This section explains our generated MPLS configuration. We will be using LDP for signaling labels, which will limit the features we can perform within the network while conversely making it easier to provision. To build an MPLS neighborship with LDP between two router interfaces, you will see in the configurations that a few parameters need to be setup: Enable MPLS on interface We'll start by enabling the family of MPLS on the interface configuration set interfaces ge-0/0/1.0 family mpls Configure MPLS and LDP Adding our interface to the MPLS and LDP protocols will be the end of our MPLS configuration set protocols mpls interface ge-0/0/1.0 set protocols ldp interface ge-0/0/1.0 Route Distinguisher Each router participating within the MPLS L3VPN circuit will build their route-distinguisher off a similar pattern to our loopbacks, 192.168.255.{x}:100 , where {x} represents the router's ID set routing-instances Customer1 instance-type vrf set routing-instances Customer1 route-distinguisher 192.168.255.11:100 Route Target The routes that we import and export will be managed by the target:{a}:{b} structure, where {a} represents the BGP ASN and {b} respresents the customer's ID set routing-instances Customer1 vrf-target target:300:100","title":"MPLS"},{"location":"docs/network/mpls/#overview","text":"This section explains our generated MPLS configuration. We will be using LDP for signaling labels, which will limit the features we can perform within the network while conversely making it easier to provision. To build an MPLS neighborship with LDP between two router interfaces, you will see in the configurations that a few parameters need to be setup:","title":"\ud83d\udccc Overview"},{"location":"docs/network/mpls/#enable-mpls-on-interface","text":"We'll start by enabling the family of MPLS on the interface configuration set interfaces ge-0/0/1.0 family mpls","title":"Enable MPLS on interface"},{"location":"docs/network/mpls/#configure-mpls-and-ldp","text":"Adding our interface to the MPLS and LDP protocols will be the end of our MPLS configuration set protocols mpls interface ge-0/0/1.0 set protocols ldp interface ge-0/0/1.0","title":"Configure MPLS and LDP"},{"location":"docs/network/mpls/#route-distinguisher","text":"Each router participating within the MPLS L3VPN circuit will build their route-distinguisher off a similar pattern to our loopbacks, 192.168.255.{x}:100 , where {x} represents the router's ID set routing-instances Customer1 instance-type vrf set routing-instances Customer1 route-distinguisher 192.168.255.11:100","title":"Route Distinguisher"},{"location":"docs/network/mpls/#route-target","text":"The routes that we import and export will be managed by the target:{a}:{b} structure, where {a} represents the BGP ASN and {b} respresents the customer's ID set routing-instances Customer1 vrf-target target:300:100","title":"Route Target"},{"location":"docs/network/overview/","text":"\ud83d\udccc Overview When talking about our network design, I will be referencing the following Juniper vLabs topology image below; the color tagging used within the topology makes it easier to associate a router to a specific role.","title":"Overview"},{"location":"docs/network/overview/#overview","text":"When talking about our network design, I will be referencing the following Juniper vLabs topology image below; the color tagging used within the topology makes it easier to associate a router to a specific role.","title":"\ud83d\udccc Overview"},{"location":"docs/network/routing/","text":"\ud83d\udccc Overview This page explains elements of our generated routing configurations. To best emulate a small ISP, I have opted to use OSPF between the MPLS routers, with external BGP peering with both customer connections. PE routers do the heavy lifting in an MPLS environment, P routers are unaware of the L3VPN circuit and simply have to worry about forwarding based on MPLS labels. We will reference the router PE1 for the examples below. OSPF Our L3VPN circuit will be signaled with BGP, but we'll have to learn our BGP neighbor's loopback before we can form a BGP session with it. For this task we will use OSPF to share the loopbacks between our MPLS backbone. On JunOS, we will simply enable the interface under an OSPF area within the protocols section of our configuration. set protocols ospf area 0.0.0.0 interface ge-0/0/2.0 interface-type p2p set protocols ospf area 0.0.0.0 interface ge-0/0/3.0 interface-type p2p set protocols ospf area 0.0.0.0 interface lo0.0 passive eBGP to Customer1 We will form a external BGP session to our customer to exchange routing information with. Customer1's router ce1 will not be MPLS aware, and will look extremely simple. Our pe1 configuration will find us creating a unique VRF routing instance for our neighbor. All BGP configuration for our neighbor will reside within this routing instance. set routing-instances Customer1 instance-type vrf set routing-instances Customer1 protocols bgp group Customer1 type external set routing-instances Customer1 protocols bgp group Customer1 peer-as 65000 set routing-instances Customer1 protocols bgp group Customer1 neighbor 74.51.192.1 iBGP to PE4 Every circuit needs to have a beginning and and end. From the perspective of pe1 , it is the beginning and pe4 will be the end of our L3 VPN circuit. Internal BGP is the protocol used to signal L3VPN routing information between PE routers. set protocols bgp group MPLS type internal set protocols bgp group MPLS local-address 192.168.255.11 set protocols bgp group MPLS family inet-vpn unicast set protocols bgp group MPLS peer-as 300 set protocols bgp group MPLS neighbor 192.168.255.16 We will specify our type of BGP as internal, and include the L3 VPN capability with inet-vpn unicast .","title":"Routing"},{"location":"docs/network/routing/#overview","text":"This page explains elements of our generated routing configurations. To best emulate a small ISP, I have opted to use OSPF between the MPLS routers, with external BGP peering with both customer connections. PE routers do the heavy lifting in an MPLS environment, P routers are unaware of the L3VPN circuit and simply have to worry about forwarding based on MPLS labels. We will reference the router PE1 for the examples below.","title":"\ud83d\udccc Overview"},{"location":"docs/network/routing/#ospf","text":"Our L3VPN circuit will be signaled with BGP, but we'll have to learn our BGP neighbor's loopback before we can form a BGP session with it. For this task we will use OSPF to share the loopbacks between our MPLS backbone. On JunOS, we will simply enable the interface under an OSPF area within the protocols section of our configuration. set protocols ospf area 0.0.0.0 interface ge-0/0/2.0 interface-type p2p set protocols ospf area 0.0.0.0 interface ge-0/0/3.0 interface-type p2p set protocols ospf area 0.0.0.0 interface lo0.0 passive","title":"OSPF"},{"location":"docs/network/routing/#ebgp-to-customer1","text":"We will form a external BGP session to our customer to exchange routing information with. Customer1's router ce1 will not be MPLS aware, and will look extremely simple. Our pe1 configuration will find us creating a unique VRF routing instance for our neighbor. All BGP configuration for our neighbor will reside within this routing instance. set routing-instances Customer1 instance-type vrf set routing-instances Customer1 protocols bgp group Customer1 type external set routing-instances Customer1 protocols bgp group Customer1 peer-as 65000 set routing-instances Customer1 protocols bgp group Customer1 neighbor 74.51.192.1","title":"eBGP to Customer1"},{"location":"docs/network/routing/#ibgp-to-pe4","text":"Every circuit needs to have a beginning and and end. From the perspective of pe1 , it is the beginning and pe4 will be the end of our L3 VPN circuit. Internal BGP is the protocol used to signal L3VPN routing information between PE routers. set protocols bgp group MPLS type internal set protocols bgp group MPLS local-address 192.168.255.11 set protocols bgp group MPLS family inet-vpn unicast set protocols bgp group MPLS peer-as 300 set protocols bgp group MPLS neighbor 192.168.255.16 We will specify our type of BGP as internal, and include the L3 VPN capability with inet-vpn unicast .","title":"iBGP to PE4"}]}